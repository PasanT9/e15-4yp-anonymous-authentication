<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      name="description"
      content="Projects | Department of Computer Engineering, University of Peradeniya"
    />
    <meta name="author" content="Department of Computer Engineering" />
    <link rel="icon" href="/assets/images/favicon.ico" />

    <title>Projects | Department of Computer Engineering</title>

    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900"
      rel="stylesheet"
    />
    <link href="/assets/css/index.css" rel="stylesheet" />

    <!-- Begin Jekyll SEO tag v2.6.1 -->
    <meta name="generator" content="Jekyll v3.9.0" />
    <meta property="og:locale" content="en_US" />
    <meta name="description" content="Github Page Template" />
    <meta property="og:description" content="Github Page Template" />
    <link rel="canonical" href="http://localhost:4000/" />
    <meta property="og:url" content="http://localhost:4000/" />
    <script type="application/ld+json">
      {
        "@type": "WebSite",
        "url": "http://localhost:4000/",
        "description": "Github Page Template",
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->
  </head>
  <body>
    <div class="container">
      <header class="blog-header pt-3 pb-2 mb-0">
        <div class="row flex-nowrap justify-content-between align-items-center">
          <div class="col-2 pt-1">
            <img
              class="mx-auto d-block img-fluid img-logo"
              src="/assets/images/crest.png"
              alt="Logo"
            />
          </div>
          <div class="col-8">
            <a class="blog-header-logo text-dark" href="#">
              Projects - Department of Computer Engineering <br />
              <small class="small">University of Peradeniya, Sri Lanka</small>
            </a>
          </div>
          <div class="col-2 d-flex justify-content-end align-items-center">
            <a
              class="d-none btn btn-sm btn-outline-secondary"
              href="http://www.ce.pdn.ac.lk"
              target="_blank"
              >Visit Department Site</a
            >
          </div>
        </div>
      </header>
    </div>

    <main role="main" class="container pt-3" style="min-height: 90vh">
      <div class="container px-5">
        <h1 id="project-title">
          Anonymous and Distributed Authentication for Peer to Peer Networks
        </h1>

        <h4 id="team">Team</h4>

        <ul>
          <li>
            E/15/350, Pasan Tennakoon,
            <a href="mailto:name@email.com">pasan96tennakoon@gmail.com</a>
          </li>
          <li>
            E/15/350, Supipi Karunathilaka,
            <a href="mailto:name@email.com">supipivirajini@gmail.com></a>
          </li>
        </ul>

        <h4 id="supervisors">Supervisors</h4>

        <ul>
          <li>
            Dr. Janaka Alawathugoda,
            <a href="mailto:name@eng.pdn.ac.lk">alawatugoda@eng.pdn.ac.lk</a>
          </li>
        </ul>

        <h4 id="table-of-content">Table of content</h4>

        <ol>
          <li><a href="#abstract">Abstract</a></li>
          <li><a href="#related-works">Related works</a></li>
          <li><a href="#methodology">Methodology</a></li>
          <li>
            <a href="#experiment-setup-and-implementation"
              >Experiment Setup and Implementation</a
            >
          </li>
          <li><a href="#results-and-analysis">Results and Analysis</a></li>
          <li><a href="#conclusion">Conclusion</a></li>
          <li><a href="#links">Links</a></li>
        </ol>

        <hr />

        <h2 id="abstract">Abstract</h2>

        <h5>Authentication in P2P</h5>

        Absence of a central server makes authentication in peer to peer (P2P)
        networks complex. Traditional cryptographic principles like Public Key
        Infrastructure (PKI) or Identity based Public Key Certificates (ID-PKC)
        are based on a trusted third party. Establishinga trusted third party in
        a semi-trusted network like P2P is a questionable task. Many P2P
        networks propose trust and reputation management schemes to solve this
        problem. Some use trust and reputation schemes to discover peers that
        can be considered as trusted peers of the network. These trusted peers
        are used in authentication as trusted third parties. The idea of
        reputation management systems is to evaluate a peer’s trustworthiness
        based on its interactions with other peers. There exist plenty of
        research in this area; EigenTurst, NICE, Regret, PeerTurst, FuzzyTrust.
        P2P systems that use reputation managements schemes to assist in
        authentication suffer from an obvious flow. These schemes assume that
        the reputation system is intelligentenough not to select malicious users
        as trusted peers. Trusting malicious peers to protect sensitive
        information can harm the system. For example, CST elect a set of peers
        asRPs (Reputed Peers) using EigenTrust. CST creates a pseudo-identity to
        hide the real identity of the user. The link between the identity and
        the pseudo-identity is broken into parts and stored in randomly selected
        RPs to protect users’ privacy. CST trusts RPs to protect the users’
        identity. However, EigenTrust is vulnerable to collaborative attacksand
        therefore there exist a possibility that malicious peers are elected as
        RPs. MaliciousRPs can reveal the identity of a user and exploit their
        privacy.Some researches suggest using a modified PKI for authentication
        in P2P ne
        
        <h2> Introduction </h2>
        <h3> Background </h3>
        <p> The concept of Peer to peer (P2P) communication has gained significant 
            attention in the network community over the years. Since the release of 
            Napster in 1998 many P2P applications have been introduced. Bitcoin\cite{Nakamoto}, 
            BitTorrent, TOR\cite{Dingledine}, Freenet\cite{Clarke01freenet:a}, etc are some of 
            the more popular P2P applications. The absence of centralized authority is the main
            reason behind the popularity of P2P applications. This eliminates the need for an 
            expensive central server. Also removes the vulnerability of a single point of failure. 
            P2P networks are considered to be more efficient and scalable than traditional client-server 
            applications.
        </p>

        <p> The decentralized nature of P2P networks makes it difficult to integrate traditional
            authentication mechanisms. Due to this many such networks focus on providing user 
            anonymity rather than authentication. The reduced security of these networks has created
            a lot of possible threats \cite{Wallach}. These threats can vary from uploading malicious 
            files to famous Sybil attacks \cite{Douceur}. Also, the anonymity feature of these networks 
            has created a safe house for cybercriminals \cite{Jardine}. Not being accountable for his/her 
            actions, held responsible and punished for malicious actions, P2P users have the freedom to 
            misbehave. This can cause harm to the network and its users.
        </p> 
        
        <h3> The problem </h3>
        <p> We suggest that even in an anonymous network there should be some level of accountability
            to protect the network and its users. Accountability is achieved through authentication. 
            To integrate an authentication mechanism into an anonymous P2P environment we need to solve 
            two main challenges.
        </p>
        
        <ul>
            <li> Authenticate in a decentralized environment. </li>
            <li> Authenticate without revealing identity. </li>
        </ul>
        
        <p> These two points have been discussed separately since the start of the internet. Each point 
            has its own difficulties and challenges. Authentication needs to tackle problems like the 
            absence of a central server, certificate management in a distributed environment, the 
            semi-trusted nature of peers, the unpredictable availability of peers, etc.  Authentication 
            need to solve problems like not revealing sensitive information about authenticating party's 
            identity, secure against misbehaving parties (cheating verifiers and cheating provers), 
            unlinkability of authentication sessions, practicality, etc. 
        </p>
        
        <h3> The proposed solution </h3>

        In this paper, we propose three new approaches for anonymous authentication in P2P networks 
        to solve the above problems. 
        
        <ol>
          <li>Ring signature based approach.</li>
          <li>Authenticated key sharing based approach.</li>
          <li>Zero knowledge proof based approach.</li>
        </ol>
        
        We deploy these protocol in a P2P environment where certificates are managed by peers with elevated 
        privileges (super peers). To solve the problems of semi-trusted nature and unpredictable availability 
        of peers we utilize Shamir's secret sharing\cite{Adi} technique. A more detailed explanation of these 
        cryptographic primitives is given in section 3. Then we test the performance of these ideas in 
        a practical environment developed using the .Net framework.
        
        <h2> Deliverable and milestones </h2>

        <h2> Outline of the report </h2>

        <p>The organization of the paper as follows. In section 2 we present related works in authentication 
           in P2P and anonymous authentication in P2P. Section 3 gives a brief introduction to cryptographic 
           primitives that we used. In section 4 we present the implementation design of the P2P environment 
           including certificate management. Section 5 introduce the proposed authentication protocols including 
           security proofs for the two latter protocols. We review the experimental results and do a performance analysis 
           in section 6. Section 7 conclude our research.  
        </p>
        
        
        <h2 id="related-works">Related works</h2>

        <h3> Authentication in P2P </h3>
        
        <p> Absence of a central server makes authentication in peer to peer (P2P) networks complex. Traditional 
            cryptographic principles like Public Key Infrastructure (PKI) or Identity based Public Key Certificates 
            (ID-PKC) are based on a trusted third party. Establishing a trusted third party in a semi-trusted network 
            like P2P is a questionable task. Many P2P networks propose trust and reputation management schemes to solve 
            this problem.\cite{Gokhale} ,\cite{Xiaoliang},  \cite{Tsangs} use trust and reputation schemes to discover 
            peers that can be considered as trusted peers of the network. These trusted peers are used in authentication 
            as trusted third parties.
        </p>
        <p> The idea of reputation management systems is to evaluate a peer’s trustworthiness based on its interactions 
            with other peers. There exist plenty of research in this area; EigenTurst \cite{Kamvar}, NICE\cite{Lee}, 
            Regret \cite{Sabater-Mir},  PeerTurst\cite{Xiong}, FuzzyTrust \cite{Song}.
        </p>
        <p> P2P systems that use reputation managements schemes to assist in authentication suffer from an obvious flow. 
            These schemes assume that the reputation system is intelligent enough not to select malicious users as 
            trusted peers. Trusting malicious peers to protect sensitive information can harm the system. For example, 
            CST \cite{Wang} elect a set of peers as RPs (Reputed Peers) using EigenTrust. CST creates a pseudo-identity 
            to hide the real identity of the user. The link between the identity and the pseudo-identity is broken into 
            parts and stored in randomly selected RPs to protect users’ privacy. CST trusts RPs to protect the users’ 
            identity. However, EigenTrust is vulnerable to collaborative attacks and therefore there exist a possibility 
            that malicious peers are elected as RPs. Malicious RPs can reveal the identity of a user and exploit their privacy.
        </p>
        <p> Some researches suggest using a modified PKI for authentication in P2P networks \cite{Oh}, \cite{Josephson}. 
            Rather than having a single centralized authority, the responsibility of the Certificate Authority (CA) is 
            distributed across multiple peers in the network. This improves the scalability and robustness of the authentication 
            process.
        </p>  
        <p> The downside of using PKI in P2P is certificate management becomes complex. The authentication process becomes 
            difficult to implement effectively. \cite{Josephson} use a set of peers as Authentication Servers (ASs). Even 
            though this improves the scalability of the network, introduce new security risks like unreliability in certificate 
            access and verification.
        </p>  
        <p> To solve the problem of the absence of a centralized authority and at the same time keep the authentication process 
            reliable, modern authentication schemes utilize blockchain technology. There is a lot of literature that proposes 
            the idea of using blockchain technology to create a Distributed PKI \cite{Papageorgiou}, \cite{Karaarslan}, \cite{Yakubov}, 
            \cite{Orman}. This seems to be a good solution to overcome the limitations of having a central trusted certificate authority. 
            Blockchain can make the process of a CA distributed, immutable and transparent. Therefore can successfully solve the problems 
            of malicious CAs, MITM attacks and single point of failure. Blockchain is used as a distributed key-value data storage. 
            The data is public and readable to everyone.\cite{Sivakumar2017}  propose the idea of using smart contracts to certificate management. 
        </p>
        <p> The DPKI is only secure as long as honest nodes control collectively more than 51&percnt;of computing power. Also some argues the need 
            of blockchain to decentralized PKI since the technology of blockchain is still new to the industry.
        </p>
        <p> The PGP Web of Trust \cite{Bob2005ThePT} is another way to navigate the problem of not having a trusted central authority. 
            WoT distribute the responsibility of a CA among users. The core concept of WoT is trust chains. For a simpler explanation, 
            assume A wants to authenticate himself to B. There is a user C who trusts B. C can sign A’s certificate after verifying its 
            authenticity. Then A can send the signed certificate to B. Since C has signed A’s certificate and B trusts C. B can trust A’s 
            certificate is authentic. Using indirect trust chains WoT creates a community of trusted users. However WoT is not suitable 
            P2P networks since, it is difficult for a new peer to join the network without personally knowing a existing user of the network.
        </p>
        
        <h3> Anonymous Authentication in P2P </h3>

        <p> The concept of anonymous authentication has been around for sometime. Pseudo Trust\cite{LuLi} has been one of the more popular 
            publications of this topic. Pseudo Trust (PT) utilize the concept of double pseudonyms combine with zero knowledge proofs to 
            authenticate users anonymously. PT also uses onion routing\cite{Dingledine} and EigenTrust\cite{Kamvar} trust management to provide 
            a complete file delivery system with anonymous authentication. The anonymity comes from the one way property of the cryptographic 
            hash functions. PT neglect one important feature of using the concept of pseudonyms to obtain anonymity. PT does not change PI 
            (pseudo identity) prior to each authentication process. The PT protocol requires PIC (certificate of pseudo identity) to be send 
            to the other party to start the authentication. Since PIC is same for a user, an eavesdropper can link two communication sessions 
            to a specific user.
        </p>
        <p> \cite{Han2020} proposes an similar authentication scheme to PT for Internet of Vehicles (IoV). The only difference is the slight 
            change of the zero knowledge proof and absence of onion routing the trust management. This also suffers from the same vulnerabilities 
            as PT.
        </p>  
        <p> \cite{Tsangs} present an interesting approach to anonymous authentication. PPAA uses tags to obtain anonymity and at the same time 
            link communication sessions. The idea is to use IDs of the two parties involved in the communication session create a tag. The two 
            parties will not learn any knowledge other than the tag from running the protocol. To avoid having the same tag for different 
            communication sessions between the same parties PPAA propose to include an event id into the tag design. Therefore only a party 
            involved in the communication will be able to link a communication session to a previous session with the same party. The PPAA is 
            secure in random oracle model if eXternal Diffie-Hellmam (XDH) and q-SDH assumption holds.
        </p>  
        <p> CST\cite{Xiaoliang} uses collaboration signature to authenticate users anonymously. As mentioned in section 2.1 CST uses EigenTrust\cite{Kamvar} 
            reputation system to select trusted peers (RPs). This is not safe in a semi-trusted environment like P2P networks. Other than that CST is said to 
            be resilient against impersonate attacks, traceability and collaboration attacks.
        </p>  
        <p> \cite{Sun} presents a similar method as CST. They use FBST\cite{Piveteau}[Fair Blind Signatures] to present novel authentication scheme that 
            keep the anonymity of honest users. Similar to CST this uses a trust management system called SOBIE to elect peers as super peers (SPs) and 
            reputed peers (RPs). They are assumed to be trust worthy and play and important role in authentication. However, as mentioned previously trust 
            management systems are not perfect. Malicious peers can get elected as SPs and RPs and they are able to revoke users' anonymity. Similar to CST, 
            \cite{Sun} uses the concept of Shamir's secret sharing \cite{Adi} to reduce the vulnerability of exposed RPs. \cite{Adi}[How to share a secret] 
            present a way to break a key and store it in multiple places and recreate the key when required. \cite{Sun} use this technique to break the key 
            (link between ID and pseudo ID) and store it among multiple RPs. Therefore even if few RPs got compromise it does not reveal user's identity. 
            Also a user use anonymous multicast to communicate with a SP. This makes it impossible for a SP to reveal an identity of a user.
        </p>
        <p> \cite{Wierzbicki2005} uses an combination of Merkle's puzzles\cite{Pasini} and zero knowledge proofs to provide anonymous authentication.
        </p>
        
        
        <h2 id="methodology">Methodology</h2>
        
        <h3> Cryptographic Primitives </h3>

        <h4> Zero Knowledge Proof </h4>

        <p> Zero knowledge Proof (ZKP) is a protocol that allows a prover to prove the possession of some secret to a verifier without revealing the secret 
            or any information related to the secret. The first idea of ZKP was introduced by Shafi Goldwasser, Silvio Micali, and Charles Rackoff in 
            \cite{inbook}. Since then many different ZKPs have been published \cite{Tang}, \cite{Feige}, \cite{Cramer}, \cite{Sahai}. ZKPs are widely used 
            in cryptography to implement cryptographic protocols due to its privacy, authentication and low complexity.</p>

        <p> A zero knowledge proof consists of a prover and verifier. In a zero knowledge protocol, a prover must prove the knowledge of some secret using 
            an interactive challenge-response scheme. The protocol must not reveal any information regarding the secret other than the knowledge of prover 
            has the secret. A secure zkp must satisfy soundness, completeness and zero knowledge properties.</p>  

        <p> There are two types of zero knowledge systems; interactive zero knowledge proofs and non-interactive zero knowledge proofs \cite{Wu}. Our 
            proposed protocol uses a zkp that utilize quadratic residues in modular arithmetic.</p>

        <h4> Ring Signatures </h4>

        <p> The notion of ring signature was first introduced in 2001 by Ron Rivest, Adi Shamir and Yael Tauman Kalai in \cite{Rivest}. Ring signatures 
            are used to digitally sign messages on behalf of a group. At the same time, makes it computationally difficult to find the exact signer.</p> 

        <p> Ring signatures are designed to provide anonymity to the message signer. The same functionality is provided by group signatures \cite{Davies1991}. 
            The only difference in group signature is that it needs an authoritative entity to generate the signature. Therefore that entity can revoke the 
            anonymity of the signer. Ring signatures do not depend on a third party to generate a signature. Ring signatures are spontaneous and provide 
            unconditional anonymity.</p>

        <p> Over the years different ring signature schemes have been published with different features; threshold ring signatures \cite{Bresson}, 
            linkable ring signatures\cite{Liu}, revocable ring signatures\cite{Dennis}, traceable ring signatures\cite{Fujisaki}.</p> 

        <p> Consider a scenario where a group of k entities where each entity has a public key Pi and a corresponding secret key Si. An entity r 
            can generate a ring signature on a message m using <math>(m, P<sub>1</sub>, …, P<sub>k</sub>, S<sub>r</sub>)</math>. Anyone with the knowledge of 
            <math>m, P<sub>1</sub>, …, P<sub>k</sub></math> can verify the ring signature. No one outside the group (without a secret key <math>S<sub>i</sub></math>) 
            can generate a valid ring signature for the same group.</p>

        <h4> Shamir's Secret Sharing </h4>

        <p> In 1979 Adi Shamir introduced the concept of Shamir's secret sharing\cite{Adi}[How to Share a Secret]. This allows a secret to be divided 
            into n parts. The secret can be reconstructed with atleast t parts where <math>(1 &le; t &le; n)</math>. No knowledge about the secret can be learnt 
            with (t-1) parts.</p>

        <p> The concept is based on polynomial interpolation. The idea is to generate a polynomial f(x) of (t-1) points. First we select (t-1) random 
            positive integers such that <math>(a<sub>1</sub>, a<sub>2</sub>, .., a<sub>t-1</sub>)</math>. Then set $a_0$ to the secret we want to share. These 
            points are used to generate the polynomial f(x). </p>

        <p> <math> f(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + ... + a<sub>(t-1)</sub>x<sup>(t-1)</sup></math>

        <p> Then we get n points <math>(x<sub>i</sub>, y<sub>i</sub>)</math> corresponding to the polynomial. Given any subset of t points <math>a<sub>0</sub></math> 
            can be found by lagrange basis interpolation.</p> 

        
        
        
        
        
         <math> l<sub>i</sub> = <box>(x - x<sub>0</sub>)<over>(x<sub>i</sub>-x<sub>0</sub>) </box> &times; 
                                <box>(x - x<sub>1</sub>)<over>(x<sub>i</sub>-x<sub>1</sub>) &times; ... &times; 
                                <box>(x - x<sub>t-1</sub>)<over>(x<sub>i</sub>-x<sub>t-1</sub>) </math>

         \[ f(x) = \sum_{i=0}^{t-1} y_il_i(x)) \]
        

        <p> The idea of Shamir's secret sharing is a popular concept in p2p systems. A p2p network does not have an centralized database to store 
            peers' keys. Storing keys in a selected set of peers might not be a good idea since p2p is a semi-trusted environment. For an example 
            when a peer request a key from another peer, he might not respond. Therefore keys need to be broken into parts and distributed among 
            multiple peers. A peer  should be able to reconstruct a key without the knowledge of all the parts. \cite{Xiaoliang}, \cite{Sun} 
            are p2p anonymous authentication mechanisms that use the concept of Shamir's secret sharing.</p>


        <h3> Conceptual design </h3>

        <h4> P2P network design </h4>

        <p> Using the .Net framework we implemented a hybrid P2P network\cite{BeverlyYang2003}. A traditional hybrid peer to peer network 
            consists of peers and super peers. Hybrid P2P systems is a combination of purely distributed P2P systems and mediated P2P systems. 
            Hybrid systems are designed to overcome the problems of the two mentioned systems. These systems provide search efficiency of mediated 
            P2P systems while maintaining the reliability of decentralization similar to pure P2P systems\cite{Backx2002}. </p>

        <p> Our P2P network consists of three types of entities; the main server, ordinary peers (hereafter mentioned as peers) and super peers. 
            A peer communicates with the main server only at the time of registration. Users join the network as peers. Peers are ordinary service 
            requestors. They are connected to the system through super peers. Every peer is assumed to be behind a NAT environment. Peers with public 
            IP addresses and higher computational power are promoted to be super peers.</p> 

        <p> Super peers have more responsibility for the system. A super peer is connected to one or more other super peers in the network and responsible 
            for one or more peers. They can communicate among other super peers using the super network. Super peers can join or leave the network at any 
            time. Dynamic behaviour of super peers should not affect the connectivity of the network. Our design of the network is able to change the 
            topology according to this dynamic behaviour of peers and maintain connectivity among existing super peers.</p>

        <p> A super peer is only responsible for nodes under his scope and does not know any information regarding other peers of the system.
            Therefore a node discovery process becomes an exhaustive task. This can be accomplished in two ways; flooding search and random walk. 
            We utilize flooding search in this project since the random walk is not guaranteed to produce results\cite{Ahmed2011}.</p>

        <h4> Distributed Certificate Management </h4>

        <p> The decentralized environment of the P2P network does not allow traditional methods of authentication. It's difficult to maintain a 
            centralized database of certificates where the availability of peers cannot be predicted. Distributing certificates among super peers is not 
            a viable solution since super peers are not always available. Therefore all the certificates under this super peer remains not accessible. Also, 
            malicious super peers might delete certificates from the network. The obvious solution is to keep multiple copies of the certificates. We propose 
            a different solution by using Shamir's secret sharing algorithm. The idea is to break the certificates into multiple parts and distribute across 
            the P2P network. When needed, the certificates can be reconstructed from a minimal subset of the parts. A more detailed explanation of the implementation 
            is given in section 3.3.1 .</p>

        <h4> Proposed Authentication Schemes </h4>

        <h5> Ring Signature Based approach </h5>
 
        <p> The characteristics of ring signatures make it an interesting primitive in obtaining anonymous authentication. Ring signatures allows a message 
            to be signed by a group of public keys. Making it impossible to identify the exact signer. The original ring signature scheme\cite{Rivest} and 
            most of the proposed ring signatures provide complete anonymity. This is not suitable for authentication. This make it impossible to revoke the 
            anonymity of malicious peers. Therefore we used the revocable ring signature scheme proposed in \cite{Dennis} to create a simple authentication 
            protocol that protect users' privacy. This is just a simple suggestion, of a way to obtain anonymous authentication using existing ring signature 
            schemes. The idea is to challenge prover to generate a ring signature using a random nonce generated by a verifier. If the prover is able to accomplish 
            this he can successfully authenticate himself.</p> 

        <h5> Authenticated key sharing based approach </h5>
 
        <p> We propose a novel authentication mechanism that allows a peer to authenticate without revealing their identity. The basic idea of the protocol 
            is to present prover a set of public keys and challenge to prove the knowledge of atleast one secret key corresponding to a public key from the set. 
            This idea is simple but the protocol should not reveal any information related to the prover's identity. Also a prover without a valid key pair 
            should not be able to authenticate himself. To accomplish that we employ a authenticated key sharing scheme introduced in \cite{Alawatugoda}.</p>


        <h5> Zero Knowledge Proof Based Approach </h5>

        <p> Zkp is a popular approach to obtain anonymous authentication in p2p networks. This technique has been utilized in \cite{LuLi}, \cite{Han2020} and 
            \cite{Tsangs}. Many of these approaches relies on pseudonyms to hide the identity. We propose a new authentication protocol that uses zero knowledge 
            proofs to hide the identity among a group of users. The protocol achieves properties similar to ring signatures. This is an modification of the Schnorr's 
            zero knowledge proof \cite{Soares2013}. The method is similar to the authenticated key sharing based approach in the sense that the challenge is to prove 
            the knowledge of a secret key in a set of public keys. However unlike previous method, we use zero knowledge proofs to do that. Therefore this method 
            achieve k anonymity. </p>


        <h3> Methodological approach </h3>

        <h4> Distributed Certificate Management </h4>

        <p> During the initial interaction of a peer, the corresponding super peer obtains the peer's certificate. The super peer breaks the certificate into n 
            parts using Shamir's algorithm. The super peer then floods these parts across the network. Once a request to recreate the certificate(s) received. 
            Super peer again floods a request(s) to collect the parts of the certificate. The super peers that are holding these parts will send them to the 
            corresponding super peers. The original certificate can be recreated as long as r parts are received by the super peer (r &le; n).

        <p> This technique allows distributing certificates in a more dynamic way. As long as r super peers can be accessed, the certificate can be recreated. 
            This method only requires minimal storage. That is, the size of a single part does not exceed the size of the certificate. This is also the more 
            flexible approach. n and r can be changed for each certificate without affecting other certificates. However, then there needs to be a way to identify 
            n and r for each certificate. </p>

        <p> n and r are performance metrics. Increasing n will increase the average key storage size in super peers. In section \rom{6} we analyze the performance 
            of increasing r while n is kept as a constant. </p>

        <h4> Proposed Authentication Schemes </h4>

        <h5> Ring Signature Based approach </h5>
 
        <p> The protocol starts by the prover collecting a set of certificates from the super peer. Prover then randomly select a subset of the certificates. 
            Then he verify the authenticity of the certificates and obtains the set of public keys from the subset of certificates using main server's public key. 
            Prover hides his own certificate among this subset of certificates and send them to the verifier to initiate the authentication. After authenticating 
            the certificates, verifier obtains the set of public keys using main server's public key. Then verifier generates a random nonce and challenge prover 
            to generate a ring signature for this random nonce, using the above set of public keys. Prover use his secret key, the set of public keys and main 
            server's public key to generate a ring signature according to the algorithm proposed in \cite{Dennis}. Prover then sends the ring signature to the 
            verifier. Verifier verifies the authenticity of the ring signature according to the random nonce he sent at the previous step. If the verification 
            is successful, authentication is complete. Otherwise verifier sends a fail message. </p>

        <h5> Authenticated key sharing based approach </h5>
 
        <p> As same as the previous approach prover collects a set of certificates from the super peer. Then randomly select a subset out of them. After 
            verifying the authenticity of the certificates prover extract the corresponding public keys. Prover mix his certificate into the subset of 
            certificates and send them to the verifier. Verifier obtains the public keys after verifying the authenticity of the certificates. Then generate 
            X = g<sup>x</sup> by selecting a random x. Then use the set of public keys to encrypt X. Thus creating a set of ciphertexts where each corresponds 
            to a different public key from the set. Since one of the public key is prover's, he will be able decrypt X with his secret key. After decrypting X, 
            prover selects a random y and calculates $Y = g^y$. Then generate $K = X^y$. K is the shared key. Then he sends Y to the verifier encrypted with 
            verifier's public key. Verifier decrypts Y. Then compute $K = Y^x$. At this stage both parties have the same shared key K. Verifier encrypts a 
            random number R using a symmetric key encryption scheme using K as the key. Then challenge prover to decrypt this and send R back. If the prover 
            generated the correct K at the previous steps, he will be able to decrypt R. Therefore prover can successfully authenticate himself. Otherwise 
            verifier sends a fail message.</p> 

        <h5> Zero Knowledge Proof Based Approach </h5>

            As same as the above two methods prover collects k certificates from the super peer. Then randomly select n-1 certificates and create $C$ and $P$ 
            vectors as the above methods. However in this method public key is $A_u = g^{a_u} mod p$ where $a_u$ is the private key. Similar to Schnorr's protocol 
            prover generates U. The difference is U contains factors of $A_i^{v_i}$ where $v_i$ is a random number. This is generated only using the collected 
            public keys (Prover's public key is not in U). Prover then send U to the verifier. Verifier sends a challenge c to the prover. Prover xor all elements 
            of $v_i$ with c to obtain $v_p$. Then mix $v_p$ among the set of $v_i$ s and send them along with the set of public keys (including prover's public key) 
            to the verifier. Prover also sends r which is $s - a_pv_p mod p$. Then prover does two steps of verification. First he xor $v_i$ s and check if it's 
            equal to c. If it is not terminate the authentication. Otherwise generate $U^{\prime}$ using r, A and $v_i$ s. If $U = U^{\prime}$ authentication is 
            successful. Otherwise sends a fail message to the prover. A more detailed explanation is given in section 4.1.3 . 
        
      
        <h2 id="experiment-setup-and-implementation">
          Experiment Setup and Implementation
        </h2>

        <h3> Proposed Schemes </h3>

        <h4> Ring Signature Based approach </h4>
 
        <h5> Registration </h5>
  
        <ol>
           <li> <p> A user has an ID which can be anything related to the identity of the user. Selects a random number $r_u$. Then generate a public key $P_u$ 
                such that </p>

           <p> \[P_u = H1(ID, r_u)\] </p>

           <p> User then generates the private key $S_u$ corresponding to $P_u$ </p>

           <p> User sends the registration request along with his ID, $P_u$ to the main server. </p>

           <li> Main server verifies the identity of the user. Then the server signs $P_u$ with his private key $S_s$ to generate $Cert_u$. Then sends $Cert_u$ to 
                the user. <li>
        </ol>
 
        <h5> Authentication </h5>
 
        <ol>
           <li> Prover collects k certificates from the super peer. Then randomly selects n-1 certificates from the the set. After verifying the authenticity of 
                the selected certificates prover generates $C = \{Cert_1, Cert_2,.., Cert_n\}$ which includes prover's certificate $Cert_p$ as well. Prover then 
                obtain each corresponding public key from the certificates to generate $P = \{P_1, P_2,.., P_n\}$. Then send C to the verifier, encrypted with 
                verifier's public key $P_v$. </li>
  
           <li> Verifier decrypts the message to obtain C. After verifying the authenticity of each $Cert_i$, verifier generates each $P_i$ using main servers 
                public key $P_s$. Then generate $H = Hash(P)$. Then sends H and a random nonce N to the prover. </li>
  
           <li> Prover generate $H^{\prime} = Hash(P)$ and if $H \neq H^{\prime}$ terminate the authentication. Otherwise use his secret key $S_p$, P and $P_s$ 
                to sign N and generate ring signature $\sigma$ using \cite{Dennis} ring signature scheme. Then send $\sigma$ to the verifier, encrypted with 
                verifier's public key $P_v$. </li>
  
           <li> Verifier decrypts the message to obtain $\sigma$. Then verify whether $\sigma$ corresponds to N using P set of public keys (obtained in step 2). 
                If the verification is success prover is successfully authenticated. Otherwise verifier sends a fail message.</li>
        </ol>


        <h4> Authenticated key sharing based approach </h4>

        <h5> Registration </h5>
  
        <ol>
           <li> <p> A user has an ID which can be anything related to the identity of the user. Selects a public $r_u$. Then generate </p>

                [P_u = H1(ID, r_u)\]

                <p> $P_u$ is the public key of the user.
                    User then generates the private key $S_u$ corresponding to $P_u$ </p>

                <p> User sends the registration request along with his ID, $P_u$ to the main server. </p>

           <li> Main server verifies the identity of the user. Then the server signs $P_u$ with his private key $S_s$ to generate $Cert_u$. Then sends 
                $Cert_u$ to the user. </li>

        </ol>
        
        <h5> Authentication </h5>

        <ol>
           <li> Prover collects k certificates from the super peer. Then randomly selects n-1 certificates from the the set. After verifying the authenticity 
                of the selected certificates prover generates $C = \{Cert_1, Cert_2,.., Cert_n\}$ $\vert$ C includes $Cert_p$ as well. Then send C to the verifier, 
                encrypted with verifier's public key ($P_v$). </li>
  
           <li> Verifier decrypts P using his secret key ($S_v$). Generate H = Hash(P). Then generate a random number x and obtain X = $g^x$. Then generate n 
                ciphertexts $CT = \{C_1, C_2, ..., C_n\} | C_i =  E_{P_i}(X | H)$. Verifier sends CT to the prover. </li>
  
           <li> item Prover selects the $C_i$ corresponding to his public key. Decrypt it using his secret key ($S_p$) to obtain X and H. Generate 
                $H^{\prime}$ = Hash(P). Check if $H = H^{\prime}$. If not terminate the session. Otherwise select a random number y to generate Y = $g^y$.  
                Then compute K = $X^y$. Prover sends Y back to the verifier encrypted with $P_v$. </li>
  
           <li> Verifier decrypts Y. Compute K = $Y^x$. Then generate another random number R, generate $E1_K(R)$. E1(.) is a symmetric key encryption scheme. 
                Then generate $H1 = Hash( R \vert K )$. Then send $E1_k(R)$ and H1 to the prover. </li>

           <li> Prover decrypts the message with his knowledge of K to obtain R. Then use R and his K to generate $H1^{\prime} = Hash( R \vert K )$. If 
                $H1 = H1^{\prime}$, prover sends R back to the verifier. Otherwise terminate the authentication session. </li>
  
           <li> Authentication is successful if the verifier obtains the same R. If not verifier sends a fail message to the prover. </li>
        </ol>

        <h4> Zero Knowledge Proof Based Approach </h4>

        <h5> Setup </h5>

        <ol>
           <li> P and Q are two large prime number where P-1 \vert Q. g is a generator of a cyclic group of $Z_P^*$ where order of the group is  Q. P, Q and g 
                are group parameters. </li>
        </ol>

 
 
        <h5> Registration </h5>
   
        <ol>
           <li> <p>A user has an ID which can be anything related to the identity of the user. Selects a random integer  $r_u$. Then generate $a_u$ </p>

           <p> a_u = H1(ID, r_u) </p>

           <p> such that $a_u$ is from [0, Q-1]. $a_u$ is the private key of the user. Then to generate the public key $A_u$ user calculates </p>

           <p> A_u = g^{a_u} mod p </p>

           <p> User sends the registration request along with his ID, $A_u$  to the main server. </p> </li>


           <li> Main server verifies the identity of the user. Then the server signs $A_u$ with his private key $K_s$ to generate $Cert_u$. Then 
                sends $Cert_u$ to the user. </li>
        </ol>

 
        <h5> Authentication </h5>

        <ol>
           <li> <p> Prover collects k certificates from the super peer. Then randomly selects n-1 certificates from the the set. After verifying the authenticity 
                of the selected certificates prover generates $C = \{Cert_1, Cert_2,.., Cert_{n-1}\}$. Prover then obtain each corresponding public key from 
                the certificates to generate $P=\{A_1, A_2, …  A_{n-1}\}$. Prover then selects a random number s from the range [0, Q-1].  Then selects another 
                n-1 random numbers from the range [0, Q-1] to generate the $V=\{v_1, v_2, …, v_{n-1}\}$. Prover calculates </p>
    
                <p> U = g^s A^{v_1} A^{v_2} … A^{v_{n-1}}</p>
     
                <p> Prover sends U to the verifier to initiate the authentication. </p>
     
           <li> Verifier selects a random number c from the range [0, Q-1] and sends it to the prover. </li>
     
           <li> <p> Prover calculates </p>
     
                <p> \[v_p = v_1 \oplus v_2 \oplus …  v_{n-1} \oplus c\] </p>

                <p> Then insert $v_p$ to the vector V such that $V=\{v_1, … v_p, … v_{n-1}\}$. Prover also update $C=\{Cert_1, ..., Cert_p, ..., Cert_{n-1}\}$ 
                   where  $Cert_p$ is prover's certificate. Then calculates </p>

                <p> \[r = s - a_pv_p mod p\] </p>

                <p> Prover sends r, V, C to the verifier. </p>
    
           <li> <p> After verifying the authenticity of the certificates in C. Verifier calculates </p>
    
                <p> \[c^{\prime} = v_1 \oplus v_2 \oplus  … \oplus v_n\] </p>

                <p> If $c \neq c^{\prime}$, terminate the authentication session. Otherwise calculates </p>
    
                <p> \[U^{\prime} = g^r A^{v_1} A^{v_2} … A^{v_n}\] </p>

                <p> If $U = U^{\prime}$, authentication is successful. Otherwise terminate the authentication. </p> 
           </li>
    
        </ol>


        <h3> Testing </h3>

        <p> Testing of the system was done to understand the capabilities of the system. The testing was done cloud servers located in different countries. 
            Intention was to mimic a world wide distributed network. Although a simulation environment would be ideal to do load testing on the system, absence 
            of open-source platforms to simulate network environments which could run c sharp scripts was a problem. However, a real-world environment helps to 
            understand the system performance in its operating environment. The tests were done to find the limitations of key sharing mechanism and to compare the 
            performance of the three authentication protocols in a real environment. </p>

        <p> The first test was done to understand the performance of the key sharing mechanism. </p>

        <h4> Performance of key sharing </h4>

        <p> Key sharing technique is an integral part of our implementation. The number of parts the key can be broken into (n) and the number of parts required 
            to reconstruct a certificate (r) decides the availability of certificates. A high n value and low r value obtains a higher availability. Since 
            distributing the parts of the certificates happens only once, in this experiment we measure the latency of the certificate reconstruction. Specifically, 
            the experiment was done to identify how the latency of a successful certificate reconstruction varies with increasing n and r. The experiment was done 
            by setting n = r. That is all parts of the certificate are required to reconstruct the certificate. First we break a randomly created certificate into 
            n parts and distribute across the P2P network. Then we floods a SEARCH message requesting the parts of the certificate. The time was measured from the 
            time of flooding the SEARCH message until the successful reconstruction of the certificate. We started with breaking the certificate into 2 parts and 
            at each step we increased n by 2. We continued the experiment until n reached 20. For each n the experiment was done three times and we measured the 
            average time. We also removed any outliers that could affect the results. </p>

        <p> Due to limited resources, we used only four publicly available servers each in a different country. The selected servers were located in Singapore, 
            India, America and France. Multiple super-node instances were created at each server and super-nodes were connected so that no two neighbour-nodes 
            reside in the same country. This is to intentionally increase the latency of communication. </p>

        <h4> Performance of authentication protocols </h4>

        <p> Anonymity of the authentication protocols depend on the number of certificates. Higher the number of certificates used in the protocol higher the 
            anonymity of the prover. Therefore it is important that a protocol can handle a higher number of certificates. This experiment was done to measure 
            the latency of a complete successful authentication session between a prover and a verifier. At each step we increased the number of ceritificates 
            used in the protocol to measure how the latency varies. The experiment was done for the three proposed protocols in hope to compare the performance. </p> 

        
        
        <h2 id="results-and-analysis">Results and Analysis</h2>
        
        <h3> Proofs of security </h3>

        <h4> Ring Signature Based approach </h4>

            The security of the protocol depends on the security of the ring signature scheme \cite{Dennis}. The authors have proven the correctness, 
            revocation correctness, unforgeability and signer anonymity of the signature scheme. They directly corresponds to the anonymity, completeness, 
            soundness of our suggested protocol. 
 
        <h5> Anonymity </h5>
            Anonymity of the protocol depends on the properties of the ring signature scheme. The scheme proves it obtains signer anonymity. The proposed 
            protocol does not reveal any information other than the set of public keys $P$. The only information verifier can deduce is prover's public 
            key $P_p$ is among the set $P$. Therefore this obtains k anonymity. 
 
        <h5> Completeness </h5>
 
        <p> If a protocol has completeness, the protocol is said to be comprehensive; an honest verifier will always be able to authenticate himself. </p>

        <p> The completeness of the protocol comes from the correctness of the ring signature scheme \cite{Dennis}. The authors of the paper have mathematically 
            proven the correctness of the ring signature scheme. Therefore our protocol is complete. </p>
 
        <h5> soundness </h5>
 
        <p> If a protocol has soundness property, the protocol is said to be truthful; a cheating prover will never be able to authenticate himself. </p>
 
        <p> Since the ring signature scheme has proven it's unforgeability, a cheating prover will not be able to forge a ring signature. The proposed 
            protocol obtains soundness. </p>
 
        <h5> Impersonation </h5>
    
        <p> Impersonation is when a malicious user (M) impersonates another user. A protocol that accomplish soundness and completeness is secure against 
            impersonation attacks. Therefore this protocol is secure against impersonation. </p>

        <h5> Replay Attacks </h5>
    
        <p> A replay attack is when an adversary saves a previously sent message(s) and replay it later to gain an advantage. Let’s assume a scenario where a 
            malicious user (hereafter mentioned as M) is eavesdropping on a authentication session. M can save message in step 1 (Msg1) and message in step 
            3 (Msg3), replay it later in the hope to authenticate himself. </p>

        <p> Msg1 is encrypted. Therefore M will not be able to reveal it's content. When Msg1 is replayed, verifier will respond with a random N and H. Without 
            the knowledge of P or C prover will not be able to generate the correct ring signature. Therefore will not be able to authenticate himself. 
            Replaying Msg3 will not gain anything unless verifier generates the same N as the original authentication. Probability of this scenario is 1/N, 
            which can be reduced by increasing the domain of N. </p>
 
        <h4> Authenticated key sharing based approach </h>
 
        <h5> Anonymity </h5>
    
        <p> The protocol hides the identity of the prover among a group of selected peers. The group is selected by the prover at random. Therefore verifier 
            cannot manipulate P to obtain a knowledge about the prover. </p>

        <p> A cheating verifier may use different x values to obtain prover's identity. Verifier will generate a set of x = \{$x_1, x_2, ..., x_n$\} and 
            generate X = \{$X_1, X_2, ..., X_n$\} $\vert$ $X_i = g^{x_i}$. Then verifier can generate CT = \{$C_1, C_2, ..., C_n$\} $\vert$ $C_i = E_{p_i}(X_i \vert H)$. 
            By doing so, verifier hope to identify which $C_i$ prover was able to decrypt. Then verifier can link that $C_i$ to corresponding $P_i$ to reveal provers 
            identity. </p>

        <p> However, this will not allow verifier to reveal prover's identity since at step 4 verifier needs to generate K without the knowledge of exact X 
           the verifier received. Therefore will not reveal any information about the prover unless verifier can successfully guess the $X_i$ prover decrypted. 
           Successfully random guessing $X_i$ has a probability of 1/n. </p>

        <p> Another possibility is using the above method and generating a vector of K = \{$K_1, K_2, ..., K_n$\} where each $K_i$ correspond to a different $x_i$. 
            Then at step 4 select a random $K_v$ and send $E1_{k_v}(R)$. By this verifier hopes to find which $K_i$ the prover generated. This can be done by 
            replicating the decryption process using the elements of K vector. Then check what $K_i$ generate a similar output. However this is not possible 
            due to H1 hash. Since this must include the correct key, prover will know the malicious intentions of the verifier and terminate the authentication 
            process.</p> 

        <p> This methods does not provide k anonymity. Since prover always terminate the authentication whenever the protocol was not correctly followed, 
            verifier can use this knowledge to reduce the scope of prover's identity. For an example, verifier generate CT as half of the $C_i$s are incorrectly 
            formed and other half is correctly formed. If the prover terminate the authentication process, prover's public key is one of the misformed public keys. 
            If the prover continues the authentication process, prover's public key is one of the correctly formed public keys. </p>


        <h5> Completeness </h5> 

        <p> If the prover indeed has a secret key corresponding to any one of the public keys in set P, prover can successfully decrypt X. Therefore can obtain 
            the correct key (k) for step 5. </p>

        <p> \[ K^/ = X^y \] </p>
        <p> \[ K^/ = (g^x)^y \] </p>
        <p> \[ K^/ = (g^y)^x\] </p>
        <p> \[ K^/ = K \] </p>

        <p> Since prover generate the correct key (K). He can successfully decrypt R. Therefore can successfully authenticate himself. </p>

        <h5> Soundness </h5>

        <p> A cheating prover does not have a secret key corresponding to any of the public keys in P. To authenticate himself as a member he has to correctly 
            guess X at step 3 or correctly guess R at step 5. Both it is statistically impossible since X and R are generated randomly by the verifier for 
            each communication session. </p>

        <p> Therefore unless prover can obtain a secret key and a corresponding public key from a another registered user, it is not possible to 
            authenticate himself. </p>

        <h5> Impersonation </h5>
    
        <p> Since protocol accomplish both soundness and completeness, this protocol is secure against impersonation attacks. </p>

        <h5> Replay Attacks </h5>
    
        <p> A replay attack is when an adversary saves a previously sent message(s) and uses it again to gain an advantage. Let’s assume a scenario where 
            a malicious user (hereafter mentioned as M) is eavesdropping on a communication session. M can save message in step 1 (Msg1) , message in step 3 
            (Msg3) and/or message in step 5 (Msg5), replay it later in the hope to authenticate himself. </p>

        <p> If Msg1 was replayed this will not gain any advantage for M. Since M does not know any secret key corresponding to the set P, he will not be able 
            to authenticate unless by random guessing X or R in step 3 and step 5. Storing Msg3 will not help since without the knowledge of y, M will not able 
            to generate K. Only possibility of succeeding in a replay attack is if the verifier generate the same R as the original authentication. Then M can 
            replay Msg5 to successfully authenticate himself as a valid prover. </p>

        <h4> Zero Knowledge Proof Based Approach </h4>

        <h5> Anonymity </h5>

        <p> The only information the protocol reveals is that the prover has the knowledge of an $a_p$. Protocol hides the $A_p$ (public key) corresponds to 
            that $a_p$ among the set of P public keys. Identifying the exact public key of the prover is not feasible. Therefore the protocol obtains k anonymity.</p>

        <h5> Completeness </h5>
   
        <p> If the prover possesses the correct $a_p$; the secret key corresponding to $A_p$, only then the prover will be able to generate r such that the U 
            generated by the verifier will be equal to the U received to the verifier at step 1. </p>

        <p> \[U' = g^r A^{v_1}  … A^{v_p} … A^{v_{n-1}}\] </p>
        <p> \[U' = g^{(s - a_pv_p)} A^{v_1}  … A^{v_p} … A^{v_{n-1}}\] </p>
        <p> \[U' = g^s g^{- a_pv_p} A^{v_1}  … (g^{a_p})^{v_p} … A^{v_{n-1}}\] </p>
        <p> \[U' = g^s g^{- a_pv_p} A^{v_1}  …  g^{ a_pv_p} … A^{v_{n-1}}\] </p>
        <p> \[U' = g^s A^{v_1} … A^{v_{n-1}}\] </p>    
        <p> \[U' = U\] </p> 
    
        <h5> Soundness </h5> 

        <p> Let's consider a cheating prover as a prover who does not possess a private key $a_p$ corresponding to a public key $A_p$.</p>

        <p> Without a $a_p$ a prover will not be able to generate $r = s - a_pv_p mod p$. </p>

        <p> At step 3, prover is required to generate $v_p$ by xoring elements of V with the challenge c. This operation ensures that xoring elements in 
            V vector (including $v_p$) at the verifier's side would generate c. Therefore to pass the first step of verification V must be well formed. 
            Without the knowledge of the valid $a_p$ a prover will not be able to generate r to cancel out the $g_{a_pv_p}$ component at the last step of 
            the verification. </p>

        <p> The only possibility is random guessing. The probability of guessing $a_p$ without any information is 1/Q. Since Q is selected to be a large 
            prime number, probability of that happening is statistically insignificant.</p>

        <h5> Impersonation </h5> 
        
        As we explained previously a protocol that accomplish soundness and completeness is secure against impersonation attacks. Therefore this protocol 
        is secure against impersonation.
    
        <h5> Replay Attacks </h5> 
    
        <p> Let’s assume a scenario where a malicious user (hereafter mentioned as M) is eavesdropping on a communication session. M can save Msg1 at step 1 
            and Msg3 at step 3, and replay the messages later in the hope to authenticate himself. </p>

        <p> When M replays Msg1 verifier will respond with a random challenge. Without the knowledge of s, $a_p$,  V and P vectors M will not able to continue 
            further. Therefore only replaying Msg1 will not be successful. Replaying Msg3 as the response for the challenge will cause the first step of the 
            verification to fail. Since c is chosen randomly by the verifier, the old $v_p$ will not correspond to the new c. Therefore xoring elements of V 
            will not be equal to c and verifier will terminate the authentication process. This will only be successful if the same c is chosen at the two 
            authentication processes. The probability of this happening is 1/Q. As mentioned in previous cases this is statistically insignificant. </p>

        <p> Modifying the Msg3 will not gain any advantage to M. As mentioned under soundness proof, without a valid $a_p$ authenticating will be infeasible.</p>
     

        <h2 id="conclusion">Conclusion</h2>

        <h2 id="links">Links</h2>

        <ul>
          <li>
            <a href="https://github.com/cepdnaclk/repository-name"
              >Project Repository</a
            >
          </li>
          <li>
            <a href="https://cepdnaclk.github.io/repository-name"
              >Project Page</a
            >
          </li>
          <li>
            <a href="http://www.ce.pdn.ac.lk/"
              >Department of Computer Engineering</a
            >
          </li>
          <li><a href="https://eng.pdn.ac.lk/">University of Peradeniya</a></li>
        </ul>
      </div>
    </main>
    <footer class="blog-footer">
      <p>
        <a href="#">Back to top</a>
      </p>
    </footer>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  </body>
</html>
